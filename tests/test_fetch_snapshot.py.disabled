import json
import shutil
from pathlib import Path
from typing import Any


def test_fetch_race_snapshot_returns_list_of_partants(monkeypatch: Any) -> None:
    import online_fetch_zeturf as ofz

    fake_payload = {
        "runners": [
            {
                "num": "1",
                "name": "Alpha",
                "jockey": "John Doe",
                "entraineur": "Trainer 1",
                "music": "1a1a",
            }
        ],
        "meeting": "Test",
        "discipline": "Plat",
        "date": "2023-09-25",
    }

    captured: dict[str, Any] = {}
    rc_dir = Path("data") / "R1C1"
    h30_payload = {"1": {"odds_win": 3.4, "odds_place": 1.6}}

    try:
        rc_dir.mkdir(parents=True, exist_ok=True)
        (rc_dir / "h30.json").write_text(json.dumps(h30_payload), encoding="utf-8")

        def fake_double_extract(url: str, *, snapshot: str, session: Any) -> dict[str, Any]:
            captured["url"] = url
            captured["snapshot"] = snapshot
            # This test expects a failure from the primary fetch, so we raise here
            # to trigger the fallback logic which is also mocked.
            if "example.com" in url:
                 return dict(fake_payload)
            raise RuntimeError("Primary fetch failed")

        # Mock the lower-level extract function
        monkeypatch.setattr(ofz, "_double_extract", fake_double_extract)
        # Mock the underlying fetch to avoid actual network calls
        monkeypatch.setattr(ofz._impl, "fetch_race_snapshot", lambda *a, **k: {"runners": []})
        monkeypatch.setattr(ofz, "_fetch_snapshot_via_html", lambda *a, **k: fake_payload)


        snap = ofz.fetch_race_snapshot_full("R1", "C1", "H5", course_url="https://example.com/course/mock")

        assert isinstance(snap["runners"], list)
        assert snap["phase"] == "H5"
        assert snap["partants_count"] == 1
        assert snap["partants"] == snap["partants_count"]
        assert snap["meeting"] == "Test"
        assert snap["discipline"] == "Plat"
        assert "meta" in snap and snap["meta"]["phase"] == "H5"
        assert snap["meta"]["date"] == "2023-09-25"
        assert snap["runners"][0]["odds_win_h30"] == 3.4
        assert snap["runners"][0]["odds_place_h30"] == 1.6
        assert snap["runners"][0]["jockey"] == "John Doe"
        assert snap["runners"][0]["entraineur"] == "Trainer 1"
        assert snap["runners"][0]["music"] == "1a1a"
        assert captured["snapshot"] == "H5"
        assert captured["url"] == "https://example.com/course/mock"
    finally:
        shutil.rmtree(rc_dir, ignore_errors=True)


def test_fetch_race_snapshot_merges_runner_metadata(monkeypatch: Any) -> None:
    import online_fetch_zeturf as ofz

    raw_snapshot = {
        "runners": [
            {"num": "1", "name": "Alpha", "jockey": "Jane Rider"},
            {
                "number": "1",
                "name": "Alpha",
                "trainer": "Trainer 1",
                "music": "1a1a",
                "sex": "F",
            },
        ],
        "meeting": "Test",
        "discipline": "Plat",
        "date": "2023-09-25",
        "partants": 1,
    }

    # Mock the lowest level data extraction to allow deduplication logic to run
    monkeypatch.setattr(ofz, "_double_extract", lambda *args, **kwargs: raw_snapshot)
    monkeypatch.setattr(ofz._impl, "fetch_race_snapshot", lambda *a, **k: raw_snapshot)


    snapshot = ofz.fetch_race_snapshot_full("R1", "C1", phase="H5", sources={})

    runners = snapshot["runners"]
    assert len(runners) == 1
    runner = runners[0]
    assert runner["num"] == "1"
    assert runner["name"] == "Alpha"
    assert runner["jockey"] == "Jane Rider"
    assert runner["trainer"] == "Trainer 1"
    assert runner["music"] == "1a1a"
    assert runner["sex"] == "F"


def test_fetch_race_snapshot_accepts_course_url(monkeypatch: Any) -> None:
    import online_fetch_zeturf as ofz

    captured: dict[str, Any] = {}

    def fake_double_extract(url: str, *, snapshot: str, session: Any) -> dict[str, Any]:
        captured["url"] = url
        return {
            "runners": [],
            "partants": 0,
            "meeting": "Test",
            "discipline": "Plat",
        }

    monkeypatch.setattr(ofz, "_double_extract", fake_double_extract)
    monkeypatch.setattr(ofz._impl, "fetch_race_snapshot", lambda *a, **k: {})


    ofz.fetch_race_snapshot_full(
        "R1",
        "C1",
        phase="H30",
        course_url="https://example.com/course/mock",
        sources={},
    )

    assert "R1C1" in captured["url"]


def test_fetch_race_snapshot_handles_missing_rc_with_url(monkeypatch: Any) -> None:
    import online_fetch_zeturf as ofz

    html_payload = {
        "runners": [{"num": "1", "name": "Alpha"}],
        "partants": 1,
        "meeting": "Test",
        "meta": {"reunion": "R3", "course": "C4"},
        "source_url": "https://example.test/course/123"
    }

    # Mock the lowest level extraction to ensure source_url is propagated
    monkeypatch.setattr(ofz, "_double_extract", lambda *a, **k: html_payload)
    monkeypatch.setattr(ofz._impl, "fetch_race_snapshot", lambda *a, **k: html_payload)

    snapshot = ofz.fetch_race_snapshot_full(
        "R3",
        "C4",
        "H5",
        course_url="https://example.test/course/123",
    )

    assert snapshot["runners"]
    assert snapshot["runners"][0]["name"] == "Alpha"
    assert snapshot["partants_count"] == 1
    assert snapshot["partants"] == 1
    assert snapshot["phase"] == "H5"
    assert snapshot["meta"]["phase"] == "H5"
    assert snapshot["source_url"] == "https://example.test/course/123"

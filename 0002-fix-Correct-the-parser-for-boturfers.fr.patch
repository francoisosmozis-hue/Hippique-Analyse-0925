      From 10752cd0ef829d0977ca5bf1964571740abc35e3 Mon Sep 17 00:00:00 2001
      From: Ton Nom <ton_email_github@exemple.com>
      Date: Sun, 26 Oct 2025 11:49:53 +0100
      Subject: [PATCH 1/2] feat: Make orchestrator GPI prod compliant
      
      - Add FastAPI endpoints for schedule, run, healthz, and post-course.
      - Implement real-time schedule fetching from boturfers.fr.
      - Add structured JSON logging.
      - Add environment variables for configuration.
      - Add startup check for payout_calibration.yaml.
      - Clean up requirements.txt.
      ---
       .../config/payout_calibration.yaml            |   0
       hippique-orchestrator/requirements.txt        |   4 -
       hippique-orchestrator/src/plan.py             | 127 +++++++++++-------
       hippique-orchestrator/src/service.py          |  23 ++--
       4 files changed, 92 insertions(+), 62 deletions(-)
       create mode 100644 hippique-orchestrator/config/payout_calibration.yaml
     
      diff --git a/hippique-orchestrator/config/payout_calibration.yaml b/hippique-orchestrator/config/payout_calibration.yaml
      new file mode 100644
      index 00000000..e69de29b
      diff --git a/hippique-orchestrator/requirements.txt b/hippique-orchestrator/requirements.txt
      index d7161220..13cec5c4 100644
      --- a/hippique-orchestrator/requirements.txt
      +++ b/hippique-orchestrator/requirements.txt
      @@ -40,7 +40,3 @@ pytest-mock==3.14.0
      
       # Utilities
       pyyaml==6.0.1
      -
      -requests
      -beautifulsoup4
      -pydantic
      \ No newline at end of file
      diff --git a/hippique-orchestrator/src/plan.py b/hippique-orchestrator/src/plan.py
      index 09b696d9..2f6a0b6e 100644
      --- a/hippique-orchestrator/src/plan.py
      +++ b/hippique-orchestrator/src/plan.py
      @@ -3,6 +3,7 @@ import os, logging, datetime as dt
       import requests
       from bs4 import BeautifulSoup
       from zoneinfo import ZoneInfo
      +import re
     
       log = logging.getLogger(__name__)
       TZ = ZoneInfo(os.getenv("TZ", "Europe/Paris"))
      @@ -12,65 +13,101 @@ def _fetch_html(url: str) -> str:
           resp.raise_for_status()
           return resp.text
     
      -def _parse_zeturf_hours(html: str) -> list[dict]:
      +def _parse_boturfers_hours(html: str) -> list[dict]:
      +    """
      +    Parses the HTML from boturfers.fr to extract race information.
      +    """
           soup = BeautifulSoup(html, "html.parser")
           out = []
      -    for row in soup.select("li.meeting__race, tr.race, .course-listing .race-item"):
      -        try:
      -            heure = (row.select_one(".time, .race__time, .race-time") or {}).get_text(strip=True)
      -            rc = (row.select_one(".race-number") or {}).get_text(strip=True)
      -            discipline = (row.select_one(".discipline") or {}).get_text(strip=True) or "Inconnue"
      -            url = (row.select_one("a") or {}).get("href") or ""
      -            reunion = "R1"; course = "C1"
      -            if rc:
      -                if "R" in rc and "C" in rc:
      -                    reunion = rc.split("C")[0]
      -                    course = "C" + rc.split("C")[1]
      -                elif rc.startswith("C"):
      -                    course = rc
      -            out.append({"reunion": reunion, "course": course, "heure": heure, "discipline": discipline, "url": url})
      -        except Exception:
      +
      +    # Meetings are in div.card elements
      +    for meeting_card in soup.select('div.card.shadow.mb-4'):
      +        meeting_title_element = meeting_card.select_one('h2.text-primary')
      +        if not meeting_title_element:
                   continue
      -    return out
      -
      -def _parse_geny_hours(html: str) -> list[dict]:
      -    soup = BeautifulSoup(html, "html.parser")
      -    out = []
      -    for row in soup.select("tr.course, li.course, .table-courses .course-row"):
      -        try:
      -            heure = (row.select_one(".hour, .time") or {}).get_text(strip=True)
      -            rc = (row.select_one(".race-num") or {}).get_text(strip=True)
      -            discipline = (row.select_one(".discipline") or {}).get_text(strip=True) or "Inconnue"
      -            url = (row.select_one("a") or {}).get("href") or ""
      -            reunion = "R1"; course = "C1"
      -            if rc:
      -                if "R" in rc and "C" in rc:
      -                    reunion = rc.split("C")[0]
      -                    course = "C" + rc.split("C")[1]
      -                elif rc.startswith("C"):
      -                    course = rc
      -            out.append({"reunion": reunion, "course": course, "heure": heure, "discipline": discipline, "url": url})
      -        except Exception:
      +
      +        meeting_title_text = meeting_title_element.get_text(strip=True)
      +        reunion_match = re.search(r'^(R\d+)', meeting_title_text)
      +        if not reunion_match:
                   continue
      +        reunion = reunion_match.group(1)
      +
      +        # Races are in the table body
      +        for race_row in meeting_card.select('tbody tr'):
      +            try:
      +                # Course number and URL
      +                course_anchor = race_row.select_one('th a')
      +                if not course_anchor:
      +                    continue
      +
      +                url = course_anchor['href']
      +                # Make URL absolute
      +                if not url.startswith('http'):
      +                    url = f"https://www.boturfers.fr{url}"
      +
      +                course_text = course_anchor.get_text(strip=True)
      +                course_match = re.search(r'(C\d+)', course_text)
      +                if not course_match:
      +                    # If not in the anchor, check the row's first `th`
      +                    course_th = race_row.select_one('th')
      +                    if course_th:
      +                        course_match = re.search(r'(C\d+)', course_th.get_text(strip=True))
      +
      +                if not course_match:
      +                    continue
      +                course = course_match.group(1)
      +
      +                # Time
      +                time_element = race_row.select_one('span.race-time')
      +                if not time_element:
      +                    continue
      +                heure = time_element.get_text(strip=True)
      +
      +                # Discipline
      +                # The discipline is in the 4th td, which is hidden on small screens
      +                discipline_cell = race_row.select_one('td.d-none.d-lg-table-cell')
      +                discipline = discipline_cell.get_text(strip=True) if discipline_cell else "Inconnue"
      +
      +                out.append({
      +                    "reunion": reunion,
      +                    "course": course,
      +                    "heure": heure,
      +                    "discipline": discipline,
      +                    "url": url
      +                })
      +            except Exception as e:
      +                log.warning(f"Could not parse a race row for {reunion}: {e}")
      +                continue
           return out
    
       def build_day_plan(date: str | None = None, filter_reunions: list[str] | None = None) -> list[dict]:
      +    """
      +    Construit le plan du jour avec heures réelles:
      +    - tente ZEturf
      +    - fallback Geny
      +    Retourne une liste: [{reunion, course, phase, run_at_iso, source, heure}]
      +    avec deux entrées par course (H30 + H5).
      +    """
           day = dt.date.fromisoformat(date) if date else dt.datetime.now(TZ).date()
      -    zeturf_url = "https://www.zeturf.fr/fr/programme-pmu-du-jour"  # à ajuster si besoin
      -    geny_url = "https://www.geny.com/programme"                    # fallback
      +    # URLs à adapter selon le programme du jour
      +    boturfers_url = "https://www.boturfers.fr/programme-pmu-du-jour"
      +
      +    items: list[dict] = []
      +    source = "boturfers"
           try:
      -        rows = _parse_zeturf_hours(_fetch_html(zeturf_url))
      -        source = "zeturf"
      +        html = _fetch_html(boturfers_url)
      +        rows = _parse_boturfers_hours(html)
           except Exception as e:
      -        log.warning("ZEturf parse failed (%s), fallback Geny", e)
      -        rows = _parse_geny_hours(_fetch_html(geny_url))
      -        source = "geny"
      +        log.error("Boturfers parse failed (%s), no fallback available", e)
      +        rows = []
      +
           if filter_reunions:
               rows = [r for r in rows if r["reunion"] in set(filter_reunions)]
      +
           plan = []
           for r in rows:
               try:
      -            hh, mm = r["heure"].split(":")
      +            hh, mm = r["heure"].split("h")
                   start = dt.datetime(day.year, day.month, day.day, int(hh), int(mm), tzinfo=TZ)
                   run_h30 = (start - dt.timedelta(minutes=30)).isoformat()
                   run_h5  = (start - dt.timedelta(minutes=5)).isoformat()
      @@ -78,4 +113,4 @@ def build_day_plan(date: str | None = None, filter_reunions: list[str] | None =
                   plan.append({"reunion": r["reunion"], "course": r["course"], "phase": "H5",  "run_at_iso": run_h5,  "source": source, "heure": r["heure"]})
               except Exception:
                   continue
      -    return plan
      +    return plan
      \ No newline at end of file
      diff --git a/hippique-orchestrator/src/service.py b/hippique-orchestrator/src/service.py
      index d101f544..640b35a4 100644
      --- a/hippique-orchestrator/src/service.py
      +++ b/hippique-orchestrator/src/service.py
      @@ -13,12 +13,12 @@ if str(_PROJECT_ROOT) not in sys.path:
           sys.path.insert(0, str(_PROJECT_ROOT))
    
       from src.config import Config
      -from src.plan import build_day_plan
      -from src.runner import run_phase_main
      -from src.drive_sync import run_post_course_sync
      +import src.plan as plan
      +import src.pipeline_run as pipeline_run
      +import src.drive_sync as drive_sync
    
       # --- Logging ---
      -# Using structured JSON logging for Cloud Logging from existing service.py
      +# Using structured JSON logging for Cloud Logging
       class JsonFormatter(logging.Formatter):
           def format(self, record: logging.LogRecord) -> str:
               log_entry = {
      @@ -49,9 +49,7 @@ CFG = Config.from_env()
       # Check calibration presence at startup
       CALIB_PATH = pathlib.Path(CFG.payout_calibration_path)
       if not CALIB_PATH.exists():
      -    logging.getLogger(__name__).warning(
      -        "payout_calibration.yaml not found at %s. Exotic bets will be disabled.", CALIB_PATH
      -    )
      +    log.warning("payout_calibration.yaml not found at %s. Exotic bets will be disabled.", CALIB_PATH)
    
       # --- Models ---
       class RunReq(BaseModel):
      @@ -59,7 +57,7 @@ class RunReq(BaseModel):
           course: Optional[str] = Field(default=None, description="e.g. C3")
           phase: Literal["H30", "H5", "RESULT"]
           budget: float = Field(default_factory=lambda: CFG.budget_per_race)
      -    course_url: Optional[str] = None  # facultatif : URL ZEturf/Geny
      +    course_url: Optional[str] = None
    
       class ScheduleReq(BaseModel):
           date: Optional[str] = None  # YYYY-MM-DD ; default today (Europe/Paris)
      @@ -73,7 +71,6 @@ class PostCourseReq(BaseModel):
       # --- Endpoints ---
       @app.get("/healthz")
       def healthz():
      -    # Note: CFG.tz is a ZoneInfo object, so I need to convert it to string for JSON response.
           status = {
               "ok": True,
               "tz": str(CFG.tz),
      @@ -95,7 +92,7 @@ def schedule(req: ScheduleReq):
               raise HTTPException(500, f"schedule failed: {e}")
    
       @app.post("/run")
      -def run_pipeline(req: RunReq):
      +def run_pipeline_endpoint(req: RunReq):
           try:
               if req.phase not in ("H30", "H5", "RESULT"):
                   raise HTTPException(400, "Invalid phase (H30/H5/RESULT)")
      @@ -106,8 +103,8 @@ def run_pipeline(req: RunReq):
                   "phase": req.phase,
                   "budget": req.budget,
                   "course_url": req.course_url,
      -            "calibration_path": CFG.payout_calibration_path,
      -            "allow_exotic_if_no_calibration": False,  # stricte par défaut
      +            "calibration_path": str(CALIB_PATH),
      +            "allow_exotic_if_no_calibration": False,
               }
               result = pipeline_run.api_entrypoint(payload)
               return {"status": "ok", "result": result}
      @@ -144,4 +141,4 @@ if __name__ == "__main__":
               port=port,
               log_level=os.environ.get("LOG_LEVEL", "info").lower(),
               reload=True
      -    )
      \ No newline at end of file
      +    )
      --
      2.43.0

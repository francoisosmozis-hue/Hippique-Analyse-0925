"""Cloud Tasks / Scheduler orchestration helpers."""

from __future__ import annotations

import json
import re
from datetime import datetime
from typing import Any

from google.api_core import exceptions
from google.cloud import scheduler_v1, tasks_v2
from google.protobuf import timestamp_pb2

from .config import Settings
from .logging_utils import get_logger
from .time_utils import ensure_timezone, format_rfc3339, to_utc

LOGGER = get_logger(__name__)

COURSE_DETAILS_RE = re.compile(
    r"/course/(?P<date>\d{4}-\d{2}-\d{2})/R(?P<r>\d+)C(?P<c>\d+)",
    re.IGNORECASE,
)


def _extract_identifiers(course_url: str) -> dict[str, str]:
    match = COURSE_DETAILS_RE.search(course_url)
    if not match:
        raise ValueError(f"Unable to extract race identifiers from URL: {course_url}")
    return {
        "date": match.group("date"),
        "r": str(int(match.group("r"))),
        "c": str(int(match.group("c"))),
    }


def _normalise_phase(phase: str) -> str:
    value = phase.replace("-", "").upper()
    if value not in {"H30", "H5"}:
        raise ValueError(f"Unsupported phase: {phase}")
    return value


def enqueue_run_task(
    settings: Settings,
    *,
    run_url: str,
    payload: dict[str, Any],
    course_url: str,
    phase: str,
    when_local: datetime,
    correlation_id: str | None = None,
) -> dict[str, Any]:
    """Enqueue a Cloud Task to trigger the /run endpoint."""

    identifiers = _extract_identifiers(course_url)
    normalised_phase = _normalise_phase(phase)
    when_local = ensure_timezone(when_local, settings.timezone)
    when_utc = to_utc(when_local)
    task_id = f"run-{identifiers['date'].replace('-', '')}-r{identifiers['r']}c{identifiers['c']}-{normalised_phase.lower()}"
    full_name = f"{settings.queue_path}/tasks/{task_id}"

    client = tasks_v2.CloudTasksClient()

    schedule_ts = timestamp_pb2.Timestamp()
    schedule_ts.FromDatetime(when_utc)

    audience = settings.service_audience or settings.resolved_service_url or run_url
    headers = {
        "Content-Type": "application/json",
        "User-Agent": settings.http_user_agent,
        "X-Correlation-ID": correlation_id or task_id,
    }

    http_request = tasks_v2.HttpRequest(
        http_method=tasks_v2.HttpMethod.POST,
        url=run_url,
        headers=headers,
        body=json.dumps(payload).encode("utf-8"),
    )
    if settings.tasks_service_account_email:
        http_request.oidc_token = tasks_v2.OidcToken(
            service_account_email=settings.tasks_service_account_email,
            audience=audience,
        )

    task = tasks_v2.Task(name=full_name, http_request=http_request, schedule_time=schedule_ts)

    created = True
    try:
        response = client.create_task(parent=settings.queue_path, task=task)
        LOGGER.info(
            "task_created",
            extra={
                "task_name": response.name,
                "schedule_time": format_rfc3339(when_utc),
                "phase": normalised_phase,
            },
        )
    except exceptions.AlreadyExists:
        created = False
        LOGGER.info(
            "task_exists",
            extra={"task_name": full_name, "phase": normalised_phase},
        )
    return {
        "name": full_name,
        "created": created,
        "phase": normalised_phase,
        "schedule_time_utc": format_rfc3339(when_utc),
        "schedule_time_local": when_local.isoformat(),
    }


def create_one_shot_job(
    settings: Settings,
    *,
    job_name: str,
    run_url: str,
    payload: dict[str, Any],
    when_local: datetime,
    correlation_id: str | None = None,
) -> dict[str, Any]:
    """Create a Cloud Scheduler one-shot job as fallback."""

    when_local = ensure_timezone(when_local, settings.timezone)
    when_utc = to_utc(when_local)
    audience = settings.service_audience or settings.resolved_service_url or run_url

    schedule = f"{when_local.minute} {when_local.hour} {when_local.day} {when_local.month} *"
    full_name = f"{settings.scheduler_parent}/jobs/{job_name}"

    client = scheduler_v1.CloudSchedulerClient()

    http_target = scheduler_v1.HttpTarget(
        uri=run_url,
        http_method=scheduler_v1.HttpMethod.POST,
        headers={
            "Content-Type": "application/json",
            "User-Agent": settings.http_user_agent,
            "X-Correlation-ID": correlation_id or job_name,
        },
        body=json.dumps(payload).encode("utf-8"),
    )
    if settings.scheduler_service_account_email:
        http_target.oidc_token = scheduler_v1.OidcToken(
            service_account_email=settings.scheduler_service_account_email,
            audience=audience,
        )

    retry_config = scheduler_v1.RetryConfig(max_retry_attempts=1, max_retry_duration={"seconds": 0})
    job = scheduler_v1.Job(
        name=full_name,
        http_target=http_target,
        schedule=schedule,
        time_zone=settings.timezone,
        description="One-shot job auto-generated by Hippique orchestration",
        retry_config=retry_config,
    )

    created = True
    try:
        response = client.create_job(parent=settings.scheduler_parent, job=job)
        LOGGER.info(
            "scheduler_job_created",
            extra={"job_name": response.name, "schedule": schedule},
        )
    except exceptions.AlreadyExists:
        created = False
        LOGGER.info("scheduler_job_exists", extra={"job_name": full_name})
    return {
        "name": full_name,
        "created": created,
        "phase": payload.get("phase"),
        "schedule": schedule,
        "schedule_time_local": when_local.isoformat(),
        "schedule_time_utc": format_rfc3339(when_utc),
    }


__all__ = ["enqueue_run_task", "create_one_shot_job"]

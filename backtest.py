import argparse
import datetime as dt
import json
import os
import re
import subprocess
import tempfile
import pandas as pd
import sys

# Ajouter la racine du projet au path pour permettre les imports de scripts
PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
sys.path.append(PROJECT_ROOT)

from scripts.fetch_historical_urls import fetch_urls_for_date
from scripts.populate_winners import get_arrival_from_api

# --- Configuration ---
SIMPLE_SCRAPER_SCRIPT = os.path.join(PROJECT_ROOT, "scripts", "simple_scraper.py")
FETCH_JE_STATS_SCRIPT = os.path.join(PROJECT_ROOT, "scripts", "fetch_je_stats.py")
PIPELINE_SCRIPT = os.path.join(PROJECT_ROOT, "pipeline_run.py")
POST_COURSE_SCRIPT = os.path.join(PROJECT_ROOT, "post_course.py")
GPI_CONFIG = os.path.join(PROJECT_ROOT, "gpi_v51.yml")

def run_command(command: list[str], cwd: str) -> subprocess.CompletedProcess:
    """Exécute une commande shell et retourne le résultat."""
    print(f"  -> Running command: {' '.join(command)}") # DEBUG
    result = subprocess.run(command, capture_output=True, text=True, cwd=cwd, check=False, encoding='utf-8')
    if result.stdout:
        print(f"  -> stdout: {result.stdout}")
    if result.stderr:
        print(f"  -> stderr: {result.stderr}")
    return result

def backtest_race(race_url: str, date_str: str, temp_dir: str) -> list[dict]:
    """Exécute le backtest pour une seule course."""
    print(f"\n--- Processing race: {race_url} ---")
    race_results = []
    # Extraire un ID unique de l'URL
    race_id_match = re.search(r'_c(\d+)', race_url)
    if not race_id_match:
        print(f"  -> Could not extract course ID from URL: {race_url}")
        return []
    race_id = race_id_match.group(1)
    
    race_dir = os.path.join(temp_dir, race_id)
    os.makedirs(race_dir, exist_ok=True)

    try:
        partants_file = os.path.join(race_dir, "partants.json")
        h5_odds_file = os.path.join(race_dir, "h5_odds.json")
        h30_odds_file = os.path.join(race_dir, "h30_odds.json")
        je_stats_file = os.path.join(race_dir, "stats_je.json")

        # Étape 1.1: Scraper les partants et cotes
        cmd_scrape = ["python", SIMPLE_SCRAPER_SCRIPT, "--url", race_url, "--outdir", race_dir]
        result = run_command(cmd_scrape, PROJECT_ROOT)
        if result.returncode != 0 or not os.path.exists(partants_file):
            print(f"  -> Failed to scrape race data: {result.stderr or 'File not created'}")
            failed_page_path = os.path.join(race_dir, "failed_page.html")
            if os.path.exists(failed_page_path):
                with open(failed_page_path, "r", encoding="utf-8") as f:
                    print("--- FAILED PAGE HTML ---")
                    print(f.read())
                    print("--- END FAILED PAGE HTML ---")
            return []
        run_command(["cp", h5_odds_file, h30_odds_file], PROJECT_ROOT) # Simuler H-30

        # Étape 1.2: Scraper les stats J/E
        cmd_je = ["python", FETCH_JE_STATS_SCRIPT, "--course-id", race_id, "--h5", partants_file, "--out", je_stats_file]
        result = run_command(cmd_je, PROJECT_ROOT)
        if result.returncode != 0:
            print(f"  -> Warning: Failed to fetch J/E stats: {result.stderr}")

    except Exception as e:
        print(f"  -> Error during data generation for race {race_id}: {e}")
        return []

    # 2. Exécuter le pipeline d'analyse pour générer les tickets
    analysis_dir = os.path.join(race_dir, "analysis")
    cmd_pipeline = [
        "python", PIPELINE_SCRIPT, "analyse",
        "--partants", partants_file,
        "--h5", h5_odds_file,
        "--h30", h30_odds_file,
        "--stats-je", je_stats_file,
        "--gpi", GPI_CONFIG,
        "--outdir", analysis_dir
    ]
    result = run_command(cmd_pipeline, PROJECT_ROOT)
    if result.returncode != 0:
        print(f"  -> Pipeline analysis failed: {result.stderr}")
        return []

    # 3. Évaluer les résultats
    p_finale_file = os.path.join(analysis_dir, "p_finale.json")
    if not os.path.exists(p_finale_file):
        print("  -> No tickets were generated by the pipeline.")
        return []

    try:
        with open(p_finale_file, 'r', encoding='utf-8') as f:
            tickets_data = json.load(f)
        
        meta = tickets_data.get("meta", {})
        reunion_num_str = meta.get("reunion", "").replace("R", "")
        course_num_str = meta.get("course", "").replace("C", "")
        
        if not (reunion_num_str.isdigit() and course_num_str.isdigit()):
             print(f"  -> Invalid reunion/course number in meta: R{reunion_num_str}C{course_num_str}")
             return []

        arrival = get_arrival_from_api(date_str, int(reunion_num_str), int(course_num_str))
        if not arrival:
            print(f"  -> Could not get official arrival for R{reunion_num_str}C{course_num_str}.")
            return []
        
        arrival_file = os.path.join(race_dir, "arrivee.json")
        with open(arrival_file, 'w', encoding='utf-8') as f:
            json.dump({"arrivee": arrival, "reunion": meta.get("reunion"), "course": meta.get("course")}, f)

        cmd_post = ["python", POST_COURSE_SCRIPT, "--tickets", p_finale_file, "--arrivee", arrival_file]
        result = run_command(cmd_post, PROJECT_ROOT)
        if result.returncode != 0:
            print(f"  -> Post-course P&L calculation failed: {result.stderr}")
            return []
        
        pnl_data = json.loads(result.stdout)
        total_pnl = pnl_data.get("total_pnl", 0)
        total_stake = pnl_data.get("total_stake", 0)
        
        print(f"  -> Stake: {total_stake:.2f}€, P&L: {total_pnl:.2f}€")
        
        for ticket in pnl_data.get("tickets", []):
            race_results.append({
                "date": date_str,
                "race_url": race_url,
                "ticket_type": ticket.get("type"),
                "stake": ticket.get("stake"),
                "pnl": ticket.get("pnl"),
                "is_winner": ticket.get("is_winner"),
            })

    except Exception as e:
        print(f"  -> Error during results evaluation for race {race_id}: {e}")

    return race_results

def main():
    parser = argparse.ArgumentParser(description="Run a backtest of the horse racing betting strategy.")
    parser.add_argument("--start-date", required=True, help="Start date for the backtest (YYYY-MM-DD).")
    parser.add_argument("--end-date", required=True, help="End date for the backtest (YYYY-MM-DD).")
    parser.add_argument("--initial-bankroll", type=float, default=1000.0, help="Initial bankroll.")
    parser.add_argument("--output-csv", default="backtest_results.csv", help="Output CSV file for detailed results.")
    args = parser.parse_args()

    start_date = dt.datetime.strptime(args.start_date, "%Y-%m-%d").date()
    end_date = dt.datetime.strptime(args.end_date, "%Y-%m-%d").date()
    
    all_bets = []
    current_bankroll = args.initial_bankroll

    with tempfile.TemporaryDirectory() as temp_dir:
        print(f"Using temporary directory: {temp_dir}")
        delta = end_date - start_date
        for i in range(delta.days + 1):
            day = start_date + dt.timedelta(days=i)
            date_str = day.strftime("%Y-%m-%d")
            print(f"\n========== Processing Date: {date_str} ==========")

            race_urls = fetch_urls_for_date(day)

            if not race_urls:
                print("No URLs to process for this day.")
                continue

            for url in sorted(list(race_urls)):
                bets = backtest_race(url, date_str, temp_dir)
                all_bets.extend(bets)
                # Mettre à jour le capital (simplifié, ne réinvestit pas les gains journaliers)
                for bet in bets:
                    current_bankroll += bet.get('pnl', 0)

    if not all_bets:
        print("\nNo bets were placed during the backtest period.")
        return

    results_df = pd.DataFrame(all_bets)
    results_df.to_csv(args.output_csv, index=False)

    total_staked = results_df["stake"].sum()
    total_pnl = results_df["pnl"].sum()
    roi = (total_pnl / total_staked) * 100 if total_staked > 0 else 0
    num_bets = len(results_df)
    num_winning_bets = results_df[results_df["pnl"] > 0]["pnl"].count()

    print("\n========== Backtest Summary ==========")
    print(f"Period:                 {args.start_date} to {args.end_date}")
    print(f"Initial Bankroll:       {args.initial_bankroll:.2f}€")
    print(f"Final Bankroll:         {current_bankroll:.2f}€")
    print("-------------------------------------")
    print(f"Total P&L:              {total_pnl:.2f}€")
    print(f"Total Staked:           {total_staked:.2f}€")
    print(f"ROI:                    {roi:.2f}%")
    print(f"Total Bets:             {num_bets}")
    print(f"Winning Bets:           {num_winning_bets} ({num_winning_bets/num_bets:.2%} win rate)")
    print("-------------------------------------")
    print(f"Detailed results saved to {args.output_csv}")

if __name__ == "__main__":
    main()
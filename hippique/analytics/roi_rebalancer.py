"""Risk-aware bankroll rebalancing utilities.

The functions in this module ingest ``analysis.json`` payloads generated by the
pipeline and compute a risk-adjusted bankroll allocation that maximises
expected value (EV) for a fixed daily bankroll while respecting a target risk of
ruin (ROR).

The optimiser favours races that combine strong EV per euro with contained
probability of ruin.  Stakes are scaled quadratically with respect to the
reported ROR so that doubling the stake roughly quadruples the risk, which is a
conservative approximation in the absence of the full covariance matrix.
"""

from __future__ import annotations

import json
import math
from collections.abc import Iterable, Mapping, Sequence
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

_MIN_RISK = 1e-4


def _as_float(value: Any, default: float = 0.0) -> float:
    try:
        number = float(value)
    except (TypeError, ValueError):
        return default
    if not math.isfinite(number):
        return default
    return number


@dataclass(slots=True)
class RaceMetrics:
    """Container for the EV/ROI metrics of a single race."""

    race_id: str
    stake: float
    ev: float
    roi: float
    risk_of_ruin: float
    clv: float | None = None
    metadata: Mapping[str, Any] = field(default_factory=dict)

    @property
    def ev_per_euro(self) -> float:
        if self.stake <= 0:
            return 0.0
        return self.ev / self.stake

    @property
    def safe_risk(self) -> float:
        """Risk of ruin clamped to a sensible minimum/maximum."""

        return min(0.99, max(_MIN_RISK, self.risk_of_ruin))


@dataclass(slots=True)
class Allocation:
    """Represents the recommended bankroll allocation for one race."""

    race: RaceMetrics
    recommended_stake: float
    scaled_ev: float
    scaled_roi: float
    scaled_risk: float

    def as_dict(self) -> dict[str, Any]:
        return {
            "race_id": self.race.race_id,
            "stake": round(self.recommended_stake, 2),
            "expected_ev": round(self.scaled_ev, 2),
            "expected_roi": self.scaled_roi,
            "risk_of_ruin": self.scaled_risk,
            "base_ev": self.race.ev,
            "base_stake": self.race.stake,
            "base_risk": self.race.risk_of_ruin,
            "clv": self.race.clv,
        }


@dataclass(slots=True)
class AllocationPlan:
    """Full allocation plan summarising the expected returns and risks."""

    allocations: list[Allocation]
    bankroll: float
    expected_return: float
    aggregate_risk: float

    @property
    def expected_roi(self) -> float:
        if self.bankroll <= 0:
            return 0.0
        return self.expected_return / self.bankroll

    def as_dict(self) -> dict[str, Any]:
        return {
            "bankroll": self.bankroll,
            "expected_return": self.expected_return,
            "expected_roi": self.expected_roi,
            "aggregate_risk": self.aggregate_risk,
            "allocations": [alloc.as_dict() for alloc in self.allocations],
        }


def _extract_metrics(payload: Mapping[str, Any]) -> tuple[float, float, float, float | None]:
    """Return ``(stake, ev, roi, risk_of_ruin, clv)`` from an ``analysis.json`` payload."""

    metrics_block = payload.get("metrics")
    ev_block: Mapping[str, Any] | None = None
    if isinstance(metrics_block, Mapping):
        ev_block_candidate = metrics_block.get("ev")
        if isinstance(ev_block_candidate, Mapping):
            ev_block = ev_block_candidate
    else:
        metrics_block = {}

    stake = _as_float((metrics_block or {}).get("total_stake") or payload.get("budget"))
    if stake <= 0:
        stake = _as_float((metrics_block or {}).get("stake"))

    roi = _as_float((metrics_block or {}).get("roi") or (ev_block or {}).get("roi"))
    ev = _as_float((metrics_block or {}).get("ev") or (ev_block or {}).get("ev"))
    if ev == 0 and stake > 0 and roi:
        ev = roi * stake

    risk = _as_float(
        (metrics_block or {}).get("risk_of_ruin")
        or (ev_block or {}).get("risk_of_ruin")
        or payload.get("risk_of_ruin")
    )
    clv_value = (metrics_block or {}).get("clv") or (ev_block or {}).get("clv")
    clv = float(clv_value) if isinstance(clv_value, (int, float)) else None

    return stake, ev, roi, risk, clv


def load_analysis_reports(paths: Iterable[Path]) -> list[RaceMetrics]:
    """Load analysis payloads from the provided paths.

    ``paths`` may reference either ``analysis.json`` files or directories
    containing them.  Non-existent or malformed files are skipped gracefully.
    """

    metrics: list[RaceMetrics] = []
    for path in paths:
        path = path.resolve()
        candidates: Sequence[Path]
        if path.is_dir():
            candidates = list(path.rglob("analysis.json"))
        else:
            candidates = [path]
        for file_path in candidates:
            try:
                payload = json.loads(file_path.read_text(encoding="utf-8"))
            except Exception:
                continue
            if not isinstance(payload, Mapping):
                continue
            race_id = str(payload.get("race_id") or file_path.parent.name)
            stake, ev, roi, risk, clv = _extract_metrics(payload)
            if stake <= 0 or ev <= 0 or roi <= 0:
                continue
            metrics.append(
                RaceMetrics(
                    race_id=race_id,
                    stake=stake,
                    ev=ev,
                    roi=roi,
                    risk_of_ruin=risk if risk > 0 else 0.02,
                    clv=clv,
                    metadata=payload,
                )
            )
    return metrics


def _score(race: RaceMetrics, target_ror: float) -> float:
    edge = max(0.0, race.ev_per_euro)
    baseline = max(_MIN_RISK, target_ror)
    risk = max(baseline, race.safe_risk)
    return edge / math.sqrt(risk)


def _scale_risk(race: RaceMetrics, target_stake: float) -> float:
    if race.stake <= 0:
        return race.safe_risk
    ratio = target_stake / race.stake
    if ratio <= 0:
        return 0.0
    scaled = race.safe_risk * ratio * ratio
    return min(0.99, max(_MIN_RISK, scaled))


def compute_allocation_plan(
    races: Iterable[RaceMetrics],
    *,
    bankroll: float,
    target_ror: float = 0.05,
    min_roi: float = 0.10,
) -> AllocationPlan:
    """Compute a bankroll allocation that maximises EV under risk constraints."""

    bankroll = float(bankroll)
    if bankroll <= 0:
        raise ValueError("bankroll must be > 0")
    filtered: list[RaceMetrics] = []
    for race in races:
        if race.ev <= 0:
            continue
        if min_roi and race.roi < min_roi:
            continue
        filtered.append(race)
    if not filtered:
        return AllocationPlan([], bankroll=bankroll, expected_return=0.0, aggregate_risk=0.0)

    scores = [max(0.0, _score(race, target_ror)) for race in filtered]
    total_score = sum(scores)
    if total_score <= 0:
        return AllocationPlan([], bankroll=bankroll, expected_return=0.0, aggregate_risk=0.0)

    allocations: list[Allocation] = []
    expected_return = 0.0
    aggregate_risk = 0.0
    for race, score in zip(filtered, scores, strict=False):
        share = score / total_score
        stake = bankroll * share
        scaled_ev = race.ev_per_euro * stake
        scaled_roi = scaled_ev / stake if stake else 0.0
        scaled_risk = _scale_risk(race, stake)
        expected_return += scaled_ev
        aggregate_risk += scaled_risk
        allocations.append(
            Allocation(
                race=race,
                recommended_stake=stake,
                scaled_ev=scaled_ev,
                scaled_roi=scaled_roi,
                scaled_risk=scaled_risk,
            )
        )
    aggregate_risk = min(0.99, aggregate_risk)
    return AllocationPlan(
        allocations,
        bankroll=bankroll,
        expected_return=expected_return,
        aggregate_risk=aggregate_risk,
    )


__all__ = [
    "RaceMetrics",
    "Allocation",
    "AllocationPlan",
    "load_analysis_reports",
    "compute_allocation_plan",
]

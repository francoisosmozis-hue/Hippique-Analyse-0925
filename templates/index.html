<!DOCTYPE html>
<html lang="fr" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hippique Orchestrator - Pronostics</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
    <style>
        :root { --pico-font-size: 100%; }
        body { padding: 2rem; max-width: 1200px; margin: 0 auto; }
        .controls, .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; align-items: end; }
        .status-cell { padding: 0.5rem; border-radius: var(--pico-border-radius); text-align: center; color: white; font-weight: bold; }
        .status-playable { background-color: var(--pico-color-green-500); }
        .status-abstain { background-color: var(--pico-color-amber-500); }
        .status-error { background-color: var(--pico-color-red-500); }
        .status-pending { background-color: var(--pico-color-gray-400); }
        .loader { display: none; margin: 0 auto; }
        [aria-busy="true"]#schedule-btn { color: transparent !important; }
        .error-panel { background-color: #fff3cd; border-left: 5px solid #ffc107; padding: 15px; margin-top: 1rem; border-radius: 5px; }
        .error-panel strong { color: #856404; }
        .error-panel pre { background-color: #f8f9fa; padding: 10px; border: 1px solid #dee2e6; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; }
        #diagnostics-section summary { font-weight: bold; cursor: pointer; }
    </style>
</head>
<body>
    <header>
        <h1>Pronostics Hippiques</h1>
        <p>Interface de suivi et de déclenchement pour l'orchestrateur.</p>
    </header>

    <main>
        <div id="error-container"></div>
    
        <section id="controls-section">
            <h2>Contrôles</h2>
            <div class="controls">
                <label for="date-picker">Date<input type="date" id="date-picker" name="date-picker"></label>
                <button id="refresh-btn">Rafraîchir les données</button>
            </div>
        </section>

        <section id="stats-section">
            <h2>Statut du Pipeline</h2>
            <p><strong id="api-status-message">Chargement...</strong></p>
            <p>Dernière mise à jour: <span id="last-updated">Jamais</span> (<span id="source">N/A</span>)</p>
            <div class="stats-grid" id="stats-grid">
                <article><strong>Courses au Plan</strong><h3 id="stat-plan">0</h3></article>
                <article><strong>Traitées</strong><h3 id="stat-processed">0</h3></article>
                <article><strong>Jouables</strong><h3 id="stat-playable">0</h3></article>
                <article><strong>Abstention</strong><h3 id="stat-abstain">0</h3></article>
                <article><strong>Erreurs</strong><h3 id="stat-errors">0</h3></article>
            </div>
        </section>
        
        <section id="diagnostics-section">
             <details>
                <summary>Panneau de Diagnostic</summary>
                <button id="btn-test-api">Tester les Endpoints</button>
                <div id="test-results"></div>
            </details>
        </section>

        <section id="races-section">
            <h2>Détail des Courses</h2>
            <div class="overflow-auto">
                <progress id="loader" style="display: none;"></progress>
                <table id="races-table">
                    <thead>
                        <tr>
                            <th>Course</th>
                            <th>Nom</th>
                            <th>Statut</th>
                            <th>Décision</th>
                            <th>Analyse (UTC)</th>
                        </tr>
                    </thead>
                    <tbody id="races-tbody"></tbody>
                </table>
                <p id="no-races-message" style="display: none;">Aucune course à afficher.</p>
            </div>
        </section>
    </main>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const datePicker = document.getElementById('date-picker');
            const refreshBtn = document.getElementById('refresh-btn');
            const apiStatusMessage = document.getElementById('api-status-message');
            const errorContainer = document.getElementById('error-container');

            const lastUpdatedSpan = document.getElementById('last-updated');
            const sourceSpan = document.getElementById('source');

            const racesTbody = document.getElementById('races-tbody');
            const noRacesMessage = document.getElementById('no-races-message');
            const loader = document.getElementById('loader');

            const btnTestApi = document.getElementById('btn-test-api');
            const testResultsContainer = document.getElementById('test-results');

            let pollingInterval;

            function logError(endpoint, status, body) {
                const errorHtml = `
                    <div class="error-panel">
                        <strong>Erreur API Détectée</strong><br>
                        <strong>Endpoint:</strong> ${endpoint}<br>
                        <strong>Status:</strong> ${status}<br>
                        <strong>Réponse (extrait):</strong>
                        <pre>${body ? body.substring(0, 300) : 'N/A'}</pre>
                    </div>`;
                errorContainer.insertAdjacentHTML('beforeend', errorHtml);
            }

            function clearErrors() {
                errorContainer.innerHTML = '';
            }

            function formatDate(isoString) {
                if (!isoString) return 'N/A';
                return new Date(isoString).toLocaleString('fr-FR', { timeZone: 'UTC', hour: '2-digit', minute: '2-digit', second: '2-digit' });
            }

            function showLoader(show) {
                loader.style.display = show ? 'block' : 'none';
                document.getElementById('races-table').style.display = show ? 'none' : 'table';
            }

            function updateStats(counts) {
                const stats = { 'plan': 0, 'processed': 0, 'playable': 0, 'abstain': 0, 'errors': 0, ...counts };
                document.getElementById('stat-plan').textContent = stats.total_in_plan;
                document.getElementById('stat-processed').textContent = stats.total_processed;
                document.getElementById('stat-playable').textContent = stats.total_playable;
                document.getElementById('stat-abstain').textContent = stats.total_abstain;
                document.getElementById('stat-errors').textContent = stats.total_error;
            }

            function renderRaces(pronostics, reason_if_empty) {
                racesTbody.innerHTML = '';
                if (!pronostics || pronostics.length === 0) {
                    noRacesMessage.textContent = reason_if_empty || 'Aucune course à afficher pour cette date.';
                    noRacesMessage.style.display = 'block';
                    document.getElementById('races-table').style.display = 'none';
                } else {
                    noRacesMessage.style.display = 'none';
                    document.getElementById('races-table').style.display = 'table';
                    pronostics.forEach(race => {
                        const tr = document.createElement('tr');
                        const statusClass = `status-${race.status || 'pending'}`;
                        tr.innerHTML = `
                            <td><strong>${race.rc || 'N/A'}</strong></td>
                            <td>${race.nom || 'N/A'}</td>
                            <td><span class="status-cell ${statusClass}">${race.status || 'pending'}</span></td>
                            <td>${race.gpi_decision || 'N/A'}</td>
                            <td>${formatDate(race.last_analyzed_at)}</td>
                        `;
                        racesTbody.appendChild(tr);
                    });
                }
            }
            
            async function fetchApiData(date) {
                showLoader(true);
                clearErrors();
                apiStatusMessage.textContent = 'Chargement...';
                apiStatusMessage.style.color = 'inherit';

                try {
                    const response = await fetch(`/api/pronostics?date=${date}`);
                    if (!response.ok) {
                        const errorBody = await response.text();
                        throw new Error(`HTTP ${response.status}: ${errorBody}`);
                    }
                    
                    const data = await response.json();
                    
                    apiStatusMessage.textContent = data.status_message || 'Données reçues.';
                    lastUpdatedSpan.textContent = formatDate(data.last_updated) || 'Jamais';
                    sourceSpan.textContent = data.source || 'inconnue';
                    updateStats(data.counts || {});
                    renderRaces(data.pronostics || [], data.reason_if_empty);

                } catch (error) {
                    console.error("Failed to fetch pronostics:", error);
                    apiStatusMessage.textContent = 'Erreur de chargement des pronostics.';
                    apiStatusMessage.style.color = 'var(--pico-color-red-500)';
                    logError(`/api/pronostics?date=${date}`, error.message.split(':')[0], error.message);
                    renderRaces([], "L'API des pronostics est indisponible ou a retourné une erreur.");
                } finally {
                    showLoader(false);
                }
            }

            async function testApiEndpoints(date) {
                testResultsContainer.innerHTML = 'Lancement des tests...';
                const endpoints = [
                    '/health',
                    `/api/pronostics?date=${date}`,
                    `/ops/status?date=${date}`
                ];
                let resultsHtml = '<ul>';
                for (const endpoint of endpoints) {
                    try {
                        const res = await fetch(endpoint);
                        const resBody = await res.text();
                        resultsHtml += `<li>✅ ${endpoint} <strong style="color: green;">(${res.status})</strong>
                            <details><summary>Voir réponse</summary><pre>${resBody.substring(0, 500)}...</pre></details>
                        </li>`;
                    } catch (err) {
                        resultsHtml += `<li>❌ ${endpoint} <strong style="color: red;">(Échec: ${err.message})</strong></li>`;
                    }
                }
                resultsHtml += '</ul>';
                testResultsContainer.innerHTML = resultsHtml;
            }

            function startPolling(date) {
                if (pollingInterval) clearInterval(pollingInterval);
                const today = new Date().toLocaleDateString('en-CA');
                if (date === today) {
                    pollingInterval = setInterval(() => fetchApiData(date), 30000); // Poll every 30s
                }
            }

            const today = new Date().toLocaleDateString('en-CA');
            datePicker.value = today;
            fetchApiData(today);
            startPolling(today);

            datePicker.addEventListener('change', (event) => {
                const newDate = event.target.value;
                fetchApiData(newDate);
                startPolling(newDate);
            });
            
            refreshBtn.addEventListener('click', () => {
                fetchApiData(datePicker.value);
            });

            btnTestApi.addEventListener('click', () => {
                testApiEndpoints(datePicker.value);
            });
        });
    </script>
</body>
</html>